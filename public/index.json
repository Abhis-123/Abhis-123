[{"content":"Introduction If you have ever taken an online course on Machine Learning, you must have come across Principal Component Analysis for dimensionality reduction, or in simple terms, for compression of data. Guess what, I had taken such courses too but I never really understood the graphical significance of PCA because all I saw was matrices and equations. It took me quite a lot of time to understand this concept from various sources. So, I decided to compile it all in one place.\nIn this article, weÂ will take a visual (graphical) approach to understand PCA and how it can be used to compress data. Basic knowledge of Linear Algebra and Matrices is assumed. If you are new to this concept, just follow along, I have tried my best to keep this as simple as possible.\nThese days, datasets containing a large number of dimensions are increasingly common and are often difficult to interpret. One example can be a database of face photographs of letâ€™s say,Â 1,000,000 people. If each face photograph has a dimension ofÂ 100x100,Â then the data of each face is 10000 dimensional (there are 100x100 = 10,000 unique values to be stored for each face). Now, if 1 byte is required to store the information of each pixel, then 10,000 bytes are required to store 1 face. Since there are 1000 faces in the database,10,000 x 1,000,000 = 10 GB will be needed to store the dataset.\nPrincipal component analysis (PCA) is a technique for reducing the dimensionality of such datasets, exploiting the fact that the images in these datasets have something in common. For instance, in a dataset consisting of face photographs, each photograph will have facial features like eyes, nose, mouth. Instead of encoding this information pixel by pixel, we could make a template of each type of these features and then just combine these templates to generate any face in the dataset. In this approach, each template will still be 100x100 = 1000 dimensional, but since we will be reusing these templates (basis functions) to generate each face in the dataset, the number of templates required will be very small. PCA does exactly this.\nHow does PCA work? This part is going to be a bit technical, so bear with me! I will try to explain the working of PCA with a simple example. Letâ€™s consider the data shown below containing 100 points each 2 dimensional (x \u0026amp; y coordinates is needed to represent each point).\nCurrently, we are using 2 values to represent each point. Letâ€™s explain this situation in a more technical way. We are currently using 2 basis functions,x as (1, 0) and y as (0, 1). Each point in the dataset is represented as a weighted sum of these basis functions. For instance, point (2, 3) can be represented as 2(1, 0) + 3(0, 1) = (2, 3). If we omit either of these basis functions, we will not be able to represent the points in the dataset accurately. Therefore, both the dimensions necessary, and we canâ€™t just drop one of them to reduce the storage requirement. This set of basis functions is actually the cartesian coordinate in 2 dimensions.\nIf we notice closely, we can very well see that the data approximates a line as shown by the red line below.\nNow, letâ€™s rotate the coordinate system such that the x-axis lies along the red line. Then, the y-axis (green line) will be perpendicular to this red line. Letâ€™s call these new x and y axes as a-axis and b-axis respectively. This is shown below.\nNow, if we useÂ aÂ andÂ bÂ as the new set basis functions (instead of usingÂ xÂ andÂ y) for this dataset, it wouldnâ€™t be wrong to say that most of the variance in the dataset is along theÂ a-axis. Now, if we drop theÂ b-axis,Â we can still represent the points in the dataset very accurately, using justÂ a-axis. Therefore, we now only need half as must storage to store the dataset and reconstruct it accurately. This is exactly how PCA works.\nPCA is a 4 step process.Â Starting with a dataset containingÂ nÂ dimensions (requiringÂ n-axes to be represented):\nFind a new set of basis functions (naxes) where some axes contribute to most of the variance in the dataset while others contribute very little. Arrange these axes in the decreasing order of variance contribution. Now, pick the topÂ kÂ axes to be used and drop the remainingÂ n-kÂ axes. Now, project the dataset onto theseÂ kÂ axes. After these 4 steps, the dataset will be compressed fromÂ n-dimensions to justÂ k-dimensions (k\u0026lt;n).\nSteps For the sake of simplicity, letâ€™s take the above dataset and apply PCA on that. The steps involved will be technical and basic knowledge of linear algebra is assumed.\nStep 1 Since this is a 2-dimensional dataset,Â n=2. The first step is to find the new set of basis functions (aÂ \u0026amp;Â b). In the explanation above, we saw that the dataset had the maximum variance along a line and we manually chose that line asÂ a-axis and the line the perpendicular to it asÂ b-axis. In practice, we want this step to be automated.\nTo accomplish this, we can find the eigenvalues and eigenvectors of the covariance matrix of the dataset. Since the dataset is 2 dimensional, we will get 2 eigenvalues and their corresponding eigenvectors. Then, the 2 eigenvectors are two basis functions (new axes) and the two eigenvalues tell us the variance contribution of the corresponding eigenvectors. A large value of eigenvalue implies that the corresponding eigenvector (axis) contributes more towards the total variance of the dataset.\nStep 2 Now, sort the eigenvectors (axes) according to decreasing eigenvalues. Here, we can see that the eigenvalue forÂ a-axisÂ is much larger than that of theb-axisÂ meaning that a-axis contributes more towards the dataset variance.\nThe percentage contribution of each axis towards the total dataset variance can be calculated as:\nThe above numbers prove that theÂ a-axisÂ contributes 99.7% towards the dataset variance and that we can drop theÂ b-axisÂ and lose just 0.28% of the variance.\nStep 3 Now, we will drop theÂ b-axisÂ and keep only theÂ a-axis.\nStep 4 Now, reshape the first eigenvector (a-axis) into a 2x1 matrix, called the projection matrix. It will be used to project the original dataset of shape(100, 2) onto the new basis function (a-axis), thus compressing it to (100, 1).\nReconstruct the data Now, we can use the projection matrix to expand the data back to its original size, with of course a small loss of variance (0.28%).\nThe reconstructed data is shown below:\nPlease note that the variance along theÂ b-axisÂ (0.28%) is lost as evident by the above figure.\nThatâ€™s all folks! If you made it till here, hats off to you! In this article, we took a graphical approach to understand how Principal Component Analysis works and how it can be used for data compression.\n","permalink":"http://localhost:1313/posts/pca-visualized/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eIf you have ever taken an online course on Machine Learning, you must have come across Principal Component Analysis for dimensionality reduction, or in simple terms, for compression of data. Guess what, I had taken such courses too but I never really understood the graphical significance of PCA because all I saw was matrices and equations. It took me quite a lot of time to understand this concept from various sources. So, I decided to compile it all in one place.\u003c/p\u003e","title":"Principal Component Analysis - Visualized"},{"content":"ðŸ”— View App ðŸ”— GitHub Description A to-do list web application built using React that allows the user to add, remove and edit their todos. Todo lists are stored in the browser local storage. I built this app while learning React.\n","permalink":"http://localhost:1313/projects/todo-list-app/","summary":"\u003ch3 id=\"-view-apphttpsarkalim-todo-listnetlifyapp\"\u003eðŸ”— \u003ca href=\"https://arkalim-todo-list.netlify.app\"\u003eView App\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"-githubhttpsgithubcomarkalimtodo-list-app\"\u003eðŸ”— \u003ca href=\"https://github.com/arkalim/todo-list-app\"\u003eGitHub\u003c/a\u003e\u003c/h3\u003e\n\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003eA to-do list web application built using \u003cstrong\u003eReact\u003c/strong\u003e that allows the user to add, remove and edit their todos. Todo lists are stored in the browser local storage. I built this app while learning \u003cstrong\u003eReact\u003c/strong\u003e.\u003c/p\u003e","title":"Todo List App"},{"content":"Description Managed end-to-end training, testing, and deployment of sentiment analysis and moderation services, including emotion detection and spam filtering. Fine-tuned large language models (LLMs) such as LLaMA3-8B, Phi3, LLaMA7B, and Mistral7B for task-specific applications in Generalized Classification and text analysis using techniques like LoRA, QLoRa, and SFT. Developed and implemented prompting techniques (CoT, BoT, and RAG) to address the instruction adherence problem in LLMs. Employed optimization techniques (pruning, quantization, efficient decoding, prompt compression) to reduce memory usage by 60-70% and achieved 2x inference speed. Created domain and task-oriented datasets for fine-tuning, enhancing instruction adherence and minimizing hallucinations in models. ","permalink":"http://localhost:1313/experience/sprinklr-ds/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eManaged end-to-end training, testing, and deployment of sentiment analysis and moderation services, including emotion detection and spam filtering.\u003c/li\u003e\n\u003cli\u003eFine-tuned large language models (LLMs) such as LLaMA3-8B, Phi3, LLaMA7B, and Mistral7B for task-specific applications in Generalized Classification and text analysis using techniques like LoRA, QLoRa, and SFT.\u003c/li\u003e\n\u003cli\u003eDeveloped and implemented prompting techniques (CoT, BoT, and RAG) to address the instruction adherence problem in LLMs.\u003c/li\u003e\n\u003cli\u003eEmployed optimization techniques (pruning, quantization, efficient decoding, prompt compression) to reduce memory usage by 60-70% and achieved 2x inference speed.\u003c/li\u003e\n\u003cli\u003eCreated domain and task-oriented datasets for fine-tuning, enhancing instruction adherence and minimizing hallucinations in models.\u003c/li\u003e\n\u003c/ul\u003e","title":"Data Scientist"},{"content":"Description Developed a full-scale video summarization tool utilizing frame selection, image captioning, and GPT-3.5 technologies. Constructed a large-scale retrieval system for searching similar queries by employing vector search techniques. Fine-tuned large language models (LLMs) to build engaging conversational systems. ","permalink":"http://localhost:1313/experience/genvr/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDeveloped a full-scale video summarization tool utilizing frame selection, image captioning, and GPT-3.5 technologies.\u003c/li\u003e\n\u003cli\u003eConstructed a large-scale retrieval system for searching similar queries by employing vector search techniques.\u003c/li\u003e\n\u003cli\u003eFine-tuned large language models (LLMs) to build engaging conversational systems.\u003c/li\u003e\n\u003c/ul\u003e","title":"Founding Member"},{"content":"Description Built a Python script that automated the movement of data from the companyâ€™s ERP system to its CRM system, increasing the order success rate from 60% to 95% and reducing average order placement time by 60%. Utilized techniques such as Linear Regression \u0026amp; Random Forests to find correlations between various variables affecting order success. Developed a Python script to automate the process of price optimization and updates in the backend system. ","permalink":"http://localhost:1313/experience/jsw/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eBuilt a Python script that automated the movement of data from the companyâ€™s ERP system to its CRM system, increasing the order success rate from 60% to 95% and reducing average order placement time by 60%.\u003c/li\u003e\n\u003cli\u003eUtilized techniques such as Linear Regression \u0026amp; Random Forests to find correlations between various variables affecting order success.\u003c/li\u003e\n\u003cli\u003eDeveloped a Python script to automate the process of price optimization and updates in the backend system.\u003c/li\u003e\n\u003c/ul\u003e","title":"Summer Intern"},{"content":"Description Guide: Prof. Dr. Prof. R. Balasubramanian (Professor and Head,, Dept. of Computer Science, IIT Roorkee)\nCollaborated in a team to build the controller for a prototype of a Biped Robot designed for agricultural applications. Gained proficiency in Webots and G-mapping tools for simultaneous localization and mapping (SLAM) for path planning. Collected and labeled data for tomato localization using YOLO and Pascal VOC formats. Implemented state-of-the-art research papers for the detection and localization of tomatoes and peduncles, fine-tuning YOLOv5 and achieving a mean Average Precision (mAP) of 73.1. ","permalink":"http://localhost:1313/experience/iit-madras/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eGuide:\u003c/strong\u003e \u003cstrong\u003eProf. Dr.  Prof. R. Balasubramanian\u003c/strong\u003e (Professor and Head,, Dept. of Computer Science, IIT Roorkee)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCollaborated in a team to build the controller for a prototype of a Biped Robot designed for agricultural applications.\u003c/li\u003e\n\u003cli\u003eGained proficiency in Webots and G-mapping tools for simultaneous localization and mapping (SLAM) for path planning.\u003c/li\u003e\n\u003cli\u003eCollected and labeled data for tomato localization using YOLO and Pascal VOC formats.\u003c/li\u003e\n\u003cli\u003eImplemented state-of-the-art research papers for the detection and localization of tomatoes and peduncles, fine-tuning YOLOv5 and achieving a mean Average Precision (mAP) of 73.1.\u003c/li\u003e\n\u003c/ul\u003e","title":"Research Associate"},{"content":"Description Developed an algorithm to calculate the greenery score of a given area based on longitude, latitude, and radius. Utilized the OpenStreetMap API to fetch relevant data, calculating the green score of Delhi at 24%. Analyzed NASAâ€™s fire data from the MODIS satellite and built a fire count prediction system for a specific region. The developed region-based fire prediction system has the potential to save tens of millions for companies affected by fire incidents. ","permalink":"http://localhost:1313/experience/go-data/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDeveloped an algorithm to calculate the greenery score of a given area based on longitude, latitude, and radius.\u003c/li\u003e\n\u003cli\u003eUtilized the OpenStreetMap API to fetch relevant data, calculating the green score of Delhi at 24%.\u003c/li\u003e\n\u003cli\u003eAnalyzed NASAâ€™s fire data from the MODIS satellite and built a fire count prediction system for a specific region.\u003c/li\u003e\n\u003cli\u003eThe developed region-based fire prediction system has the potential to save tens of millions for companies affected by fire incidents.\u003c/li\u003e\n\u003c/ul\u003e","title":"Machine Learning Researcher"}]